# LEARNED — Litestar

## Засвоєно в процесі виконання
- Використав Litestar у бекенді для основного API-сервісу.
- Ознайомився з DI, middleware та OpenAPI, зібраними у фреймворк із мінімумом “магії”.
- Переконався у високій швидкості та легкості розробки в асинхронному середовищі.

## Як інтегрував у рішення
- **Де використано в коді:** головний API-сервіс (endpoint `/events`, `/stats/*`), middleware для метрик, rate limiting, DI через `Provide`.

## Плюси / Мінуси / Трейд-офи

**Плюси**
- Висока продуктивність і легкість.
- Мінімум прихованої логіки, все прозоро.
- Просте DI, middleware і підтримка OpenAPI з коробки.

**Мінуси**
- Екосистема поки що невелика.
- Менше “батарейок” і готових інтеграцій, ніж у FastAPI або DRF.

**Коли використовувати / коли уникати**
- Використовувати, якщо потрібно створити мікросервіс або асинхронний API з фокусом на швидкість і контроль.  
- Уникати, якщо розробляєш великий моноліт або корпоративний REST, де зручніше DRF.


---

# LEARNED — NATS JetStream

## Засвоєно в процесі виконання
- Розібрався з моделлю pub/sub, durable consumer і DLQ.
- Ознайомився з ack/retry, потоками JetStream і базовими принципами EDA.
- Оцінив стабільність, швидкість і простоту масштабування.

## Як інтегрував у рішення
- **Де використано в коді:** сервіс подій — API публікує батч подій у `events_hot`, worker читає їх і записує в базу, при помилках події йдуть у `events_hot.dlq`.

## Плюси / Мінуси / Трейд-офи

**Плюси**
- Висока швидкість, мінімальна затримка.
- Простий і легкий брокер.
- Вбудована підтримка request/reply, ack/retry, durable consumers.
- Масштабування без складних конфігурацій.

**Мінуси**
- Невелика екосистема.
- Обмежені можливості для DLQ (немає з коробки розширених механізмів).
- Менше інструментів моніторингу, ніж у Kafka.

**Коли використовувати / коли уникати**
- Використовувати, якщо потрібна легка черга для real-time або event-driven архітектури, де важливі швидкість і простота.  
- Уникати, якщо потрібен тривалий журнал подій або фінансові ACID-вимоги (краще Kafka або RabbitMQ).


---

# LEARNED — ScyllaDB

## Засвоєно в процесі виконання
- Ознайомився з роботою shard-per-core архітектури.
- Налаштував з’єднання через `scylla-driver`, перевірив вставки на високих навантаженнях.
- Оцінив, як база підлаштовується під залізо та працює з мінімальними затримками.

## Як інтегрував у рішення
- **Де використано в коді:** у воркері, який читає події з NATS і записує їх у гарячий шар (ScyllaDB) для швидкого збереження перед подальшим перенесенням у ClickHouse.

## Плюси / Мінуси / Трейд-офи

**Плюси**
- Надзвичайна продуктивність і низька затримка.
- Ефективна робота з ресурсами (C++, shard-per-core).
- Автоматична оптимізація під апаратну конфігурацію.
- Висока масштабованість і доступність, навіть на HDD.

**Мінуси**
- Молоде комʼюніті, крива навчання.
- Складність у налаштуванні та тюнінгу.
- Secondary indexes працюють повільно.

**Коли використовувати / коли уникати**
- Використовувати, якщо потрібна робота з big data у реальному часі, low-latency запити, аналітика подій, IoT, метрики, логування.  
- Уникати, якщо потрібен ACID, складна аналітика (OLAP), невеликі навантаження або команда не має досвіду з NoSQL.


---

# LEARNED — ClickHouse

## Засвоєно в процесі виконання
- Ознайомився з колоночним підходом і аналітичними запитами.
- Створив власний репозиторій для аналітичних запитів (`stats service`).
- Переконався, що навіть великі агрегації виконуються практично миттєво.

## Як інтегрував у рішення
- **Де використано в коді:** у модулі аналітики (`stats`) для DAU, top-events, retention; підключення через `clickhouse-connect`.

## Плюси / Мінуси / Трейд-офи

**Плюси**
- Неймовірна швидкість аналітичних запитів.
- Висока швидкість batch-вставок і ефективне стиснення.
- SQL-подібний синтаксис, проста масштабованість.
- Оптимізовано під великі обсяги даних.

**Мінуси**
- Відсутність ACID-гарантій.
- Не підходить для частих точкових оновлень і CRUD-операцій.
- Високі вимоги до RAM, складні join-и.

**Коли використовувати / коли уникати**
- Використовувати, коли потрібна OLAP-аналітика, обробка логів, метрик, фінансових звітів чи дашбордів.  
- Уникати, коли потрібен OLTP, транзакційність або невеликі бази (<100 млн рядків) — краще PostgreSQL чи MongoDB.
